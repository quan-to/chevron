package server

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"runtime/debug"
	"testing"

	"github.com/gorilla/mux"
	remote_signer "github.com/quan-to/chevron"
	"github.com/quan-to/chevron/QuantoError"
	"github.com/quan-to/chevron/etc"
	"github.com/quan-to/chevron/etc/magicBuilder"
	"github.com/quan-to/chevron/keymagic"
	"github.com/quan-to/slog"
)

const testKeyFingerprint = "0016A9CA870AFA59"
const testKeyName = "HUEBR"
const testKeyPassword = "I think you will never guess"
const testKeyEmail = "jon@huebr.com"

const testPublicKey2 = `-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBFxY/14BCACoBkihJXnPfYx+O8nYT8k+JKFi3gyrImdO+qiZTkhQuVxjbOsV
539uKlXQBjmjbVWWRkITtLsn2+gHteDJ1uq6rhc2k5sSu8OZuvCDRY6Xi+h19gOo
eZqjuCLBGDJR0ppYU09dQNODICVMbUE0xsn676V/Bl69LXvHkXVzKxGQCRBaMhZu
I/4G/kR9dYBYFqB7iLzzN6/ygRppOAlqkXhSd+8x9zmHG4iQao+jC99b+UYp6f1A
+OXb0WJ3KxqRTCDRtIqBDxdK+IRMbk6YCW1MmQi38UuGLdcxzl+xiJmPwcnh5buH
TvYkqFJUwNyWS/GOpfCu3nyn68fS6gw0ZN9LABEBAAG0BUhVRUJSiQEfBBMBCgAT
BQJcWP9eCRCa9CQueyx7iwIbAwAApZoIAKYp3if7GOCK3ZQ44SU8VJ62/ZOhOEAD
w7LicYYlQwlIvINti+pUQKsgNfqV++HujjVKShRD7IktRKRQB1yluV8yTLAjiN0a
19UmNwQ+s7KahOicZ1GfH8VD4w2oogcmE7IMV5FEvxfzsAVPDHPb+mDZV8GA0Rf+
EoW5kRjLeJjG0oC4oNiVynw+eHM8Z3aqx4wXEVGkxCIWdJKvYmQljiT4oHf4S3XX
17Wbbc+KzJNW1/5VFeTSHHzLBGjLyWZYnKo2S8aiNdVS9rvPOIdFDcHhFylDe8zt
Xl/5GnX68EOgGysccm/O+KI9r0c6AjXrWQ1d2KJaKXbiUE5WW8eiCw4=
=xTxF
-----END PGP PUBLIC KEY BLOCK-----`

const testPublicKey2FingerPrint = "9AF4242E7B2C7B8B"

const testSignatureData = "huebr for the win!"
const testSignatureSignature = `-----BEGIN PGP SIGNATURE-----

wsFcBAABCgAQBQJcJMPWCRAAFqnKhwr6WQAA3kwQAB6pxQkN+5yMt0LSkpIcjeOS
UPqcMabEQlkD2HQrzisXlUZgllqP4jYAjFLCeErt0uu598LXO6pNTw7MnFQSfgcJ
dJF2S05GwI4k00mMNzCTn7PbJe3d96QwjbTeanoMAjHhypZKi/StbtkFpIa+t9WI
zm+EE5trFdZoE1SMOr5j85afDecl0DsGHEkKdmJ2mLK4ja3uaxsijtLd8d7mdI+Y
LbI8UnpGyWMLkK8FpjBm+BaVeNicUvqkt/LO3LwslbKAViKpdL6Gu5x7x6Q+tAyO
PZ6P6DQKjuGJl8aSv0eoKQ1TQz6vasBZNsYlasU0fM6dXny9XIucUD5sTsUpbMhw
uO/xap6i3mBtFpzSfQCo/23KHeQajXS23Al56iUr85jlSQ9+JvJhZFrU9NQa+ypq
Xi/IxrqTTvttVurXAVME1m06JirpiuD8fDdQTTboekaqLg8rXQ5eKqW0pAMIqHvf
aq97YCqxH4F3T2EE77v6D9iLnbx/+7EGHoCehTMUYiAIAhlo93Xf/hnj40Hl/N18
gYr2Yd/IYVsAoGH6AHrIyUykXgsK6RXiBy0Sa7LN14TMCnQYzG2AUvXCDf184YAQ
1obsUVANy+qxH4lwMbEoznEsAU0ppqLchX1Ixdru5/SEgSV13Qv34rMEHCdVy4Oe
1Jcr1AyB3KmDhw76PaBh
=D//n
-----END PGP SIGNATURE-----`

const testDecryptDataAscii = `-----BEGIN PGP MESSAGE-----
Version: GnuPG v2
Comment: Generated by Chevron

wcFMA6uJF6HKi88OARAADv3z9DhWy8UI/yf09QecNw//3foPoh3I1ZCEaywEXfB6
qvYTIHCdE0aKa/lMVVjv94YGog+EetedZZ6Ow6mBz0EjzQCemjgoHnq+69kf8y9V
6oUwBUUcZz6uxJsUA2y3mfvFXYvA6CWWk9H/RoJzwHO9Px7CNZHIWaAPcPP9bJkf
9VAISjWgCEHnH4O5uavrOqBaHwgtKvb/Ya3Cq/NDlpWcwxOHcBPxyml9Tcs6HA+7
dqnr3qhjeDzGYuyXQSnNI+ut37mCbISC4jniljsSWy5l1YkD/JfpMyMpN83BPbpJ
DP55rMBonzCQ+iV9Wyt0zUUrExuArjqyU/DKx1ZmoKWEv4EU6+BjutVZbc+sQIkk
lxP0E3bMLn73qm4JU6A1A9WqFd+ndP8hxSPb7EnqwvQ6A05NLl44kZ0JfULO4+a7
dhDPPlyGeur09Y0JZiA6k+uF1+dug52E5iW6ohBhki9SNG2Y6m1wez1gLDj7OBbp
upUEH488XKGNGN96DxlQxq2ujfozpMiRXN6IYy8ZqWskVInD5GNRw9n0BNomG1p4
abKUhK+YZR/B8rJCqm3wTGvCc5hrmnEcj944oNaSvWzfbAH81bl/8/as1IL616Hq
rOvKBs2YHJT51yw9U7ShzJTH/6GLuCaViq4d8Txi2a9JEpn3VOXv65ZiyLQSHrzS
4AHkXrdO3DB3CYC/qPoKyU0Z0OH2kOBn4GvhjZ/gK+MVrSDsHhivyODC4PLgauLN
9xqB4GDksZWWXn9uD3YAASYNjI95S+DE4Rd04C/kg0GzuOAMI1yFpV1OK12+heKg
nT5O4fndAA==
=FQ83
-----END PGP MESSAGE-----`

const testDecryptDataOnly = "wcFMA6uJF6HKi88OARAATyFPVauyY3PKircZ3AlTMd2Iy1/FNKVxSKg1jKBhGvPCUdRRMqaJXz4dsEWNZp//QQMN3cd3JqJhw/AEGJJUQglwnXO2bYCXj6/RzsgRKCbj9Ijo1Y33Rbu+3+huWluYEQnWBfkbhnjeIrNRXxGvqQKczXx1aA6D1CvFk8W5LUWmIngxKi+s2TxA/fqfMBETnKa6rVM625by/9Ebo7qKoeetksDYAMvEzaLwKFIQ6O+lQt1YcBnbZ3mkrtSosisRqfmndkffUGsEJJ/g16ZYhwlDUYUGj7O/mRb01edPFLQko0THpAUhT7GH4Cw939W4wqddHSxgz9pEJKt8TsOqry2oiRQ+Qus5ygyMrLp5jH6JrExgGf5dlNUOs6R1JXozWhLXSZo7+kBg4hTRkRmdSu2adNvsO8tF2qjCWd/M0p2HfLEKTdvYFh6+d93wOVDYMvXzUB7NDIGlhi6gXs/D8+Tw+ZkLpRm9iWdLO9YpFquI+964sxAz5E5iEOBipJGTVpyxsU959kQ6hJqT4EWiATYMnqpnG7hGkDfXlKcwCeDBDKsUi3KVLw4PbSnRZQh9JNFv2VhyF2zQKpXI4hyF0QZoef2OT4a7xTOdHkdkAes/fcDhr4dwvQfp0uPOH1C8LViO7bVKBFnj+zTVftI0pVJ8MV/BV0Y5ru1hcRXOp9vS4AHk3apKw1UvqtPqAcgnbNy1euHYYuBt4HXhvbrgWuO+bpowlkmIXeAx4CrgJOKtLADx4PPk454/jrek18yYVGg4AZvEDOBu4b0E4EzkNh+m6OARX0nP/ig4wqHxtuLvNoCX4WOWAA=="

var sm etc.SMInterface
var gpg etc.PGPInterface
var log = slog.Scope("TestRemoteSigner")

var router *mux.Router

func errorDie(err error, t *testing.T) {
	if err != nil {
		fmt.Println("----------------------------------------")
		debug.PrintStack()
		fmt.Println("----------------------------------------")
		t.Error(err)
		t.FailNow()
	}
}

func executeRequest(req *http.Request) *httptest.ResponseRecorder {
	rr := httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	return rr
}

func TestMain(m *testing.M) {
	slog.UnsetTestMode()
	var err error

	QuantoError.EnableStackTrace()

	u, _ := uuid.NewRandom()

	remote_signer.DatabaseName = "qrs_test_" + u.String()
	remote_signer.PrivateKeyFolder = "../tests"
	remote_signer.KeyPrefix = "testkey_"
	remote_signer.KeysBase64Encoded = false
	remote_signer.EnableRethinkSKS = true
	remote_signer.RethinkDBPoolSize = 1

	slog.UnsetTestMode()
	etc.DbSetup()
	etc.ResetDatabase()
	etc.InitTables()
	slog.SetTestMode()

	remote_signer.EnableRethinkSKS = false

	remote_signer.MasterGPGKeyBase64Encoded = false
	remote_signer.MasterGPGKeyPath = "../tests/testkey_privateTestKey.gpg"
	remote_signer.MasterGPGKeyPasswordPath = "../tests/testprivatekeyPassword.txt"

	ctx := context.Background()
	sm = magicBuilder.MakeSM(nil)
	gpg = magicBuilder.MakePGP(nil)
	gpg.LoadKeys(ctx)

	err = gpg.UnlockKey(ctx, testKeyFingerprint, testKeyPassword)

	if err != nil {
		slog.UnsetTestMode()
		log.Error(err)
		os.Exit(1)
	}

	remote_signer.EnableRethinkSKS = true
	log.Info("Adding key %s to SKS Database", testKeyFingerprint)
	pubKey, _ := gpg.GetPublicKeyAscii(ctx, testKeyFingerprint)
	log.Info("Result: %s", keymagic.PKSAdd(ctx, pubKey))
	remote_signer.EnableRethinkSKS = false

	router = GenRemoteSignerServerMux(log, sm, gpg)

	slog.SetTestMode()
	code := m.Run()
	slog.UnsetTestMode()
	etc.Cleanup()
	slog.Warn("STOPPING RETHINKDB")
	os.Exit(code)
}

func InvalidPayloadTest(endpoint string, t *testing.T) {
	r := bytes.NewReader([]byte(""))

	req, err := http.NewRequest("POST", endpoint, r)

	errorDie(err, t)

	res := executeRequest(req)

	if res.Code != 500 {
		errorDie(fmt.Errorf("expected error 500 for invalid payload"), t)
	}

	var errObj QuantoError.ErrorObject

	d, err := ioutil.ReadAll(res.Body)
	errorDie(err, t)
	err = json.Unmarshal(d, &errObj)

	if err != nil {
		errorDie(err, t)
	}

	if errObj.ErrorCode != QuantoError.InvalidFieldData {
		errorDie(fmt.Errorf("expected %s in ErrorCode. Got %s", QuantoError.InvalidFieldData, errObj.ErrorCode), t)
	}
}

func ReadErrorObject(r io.Reader) (QuantoError.ErrorObject, error) {
	var errObj QuantoError.ErrorObject
	data, err := ioutil.ReadAll(r)
	if err != nil {
		return errObj, err
	}
	err = json.Unmarshal(data, &errObj)
	return errObj, err
}
