const chevron = require('./index');


const testKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----
Version: GnuPG v2
Comment: Generated by Chevron

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
bBM=
=36ik
-----END PGP PRIVATE KEY BLOCK-----`;

const testKeyPassword = '1234567890';

const testKeyFingerprint = 'CE4503B2947E2202';

const testSignature = `-----BEGIN PGP SIGNATURE-----

wsBcBAABCgAQBQJedt7dCRDORQOylH4iAgAArvYIAMY9G3oQA0ZL7CwZmhjRfu6d
BfNst48oHJ3mSLe1oTATkkiRvJBgXaNg9aFP0rNa5Cx8Hlkhjqp0QYRmPNhKjWhD
L+LpxLasESQeWLVZnDkaz75YHw6UK6TRIsAH7Py/zgiGlNehWx3+0rjkBxEEjJgK
aM5wBDoPi4+1yAf1ZSanypb2fq3Mzy77HKtew+9BCKhC8DE9uXN6PGC4Q/LhgDON
aXS7WqLoIaB9RjvTDHbR4V8rP5pEx5s/GhJHgYAYzcJvhxog3n03GAIW3DiQdbih
h72Ll0XnpYkiiSvwz7UtfeveDSNFUSfeoOKdGsM/8rrZIexHWSJVdUc0I53ITQY=
=K6nc
-----END PGP SIGNATURE-----`;

const testQuantoSignature = `CE4503B2947E2202_SHA512_wsBcBAABCgAQBQJeenXbCRDORQOylH4iAgAAXkIIAC55fwFNQRWTrbTuSId9jsgR/BEyCHYnvb9EpEOzBJT1kRpH1wjzv8tkY1aqChoGO5vta9ksw9eu+iLd3i0jJA7WnqxXfmhmz2gx7sCUlxI+wLvbKEOQbvPljBV+3kgZv7MedHwnfvCTu249HtvWgckOvKMdvFFP8Tmx/LyD+xinl6ikZ9SLY+Jzi51oBKYvCI2ie8okU8qCzl/EJwUJ3T5U2GOL9TgErwJLuIurCTXJbGeC2/A8+XddDFdBzJbdL72o9BVC2/CLunDDuqRNwTHqHxfcGEvgITZup4LG95gOFefyFZL+QIrCEvUUhaFpvQCYvA+oJw5KTASiL25vTEo==uzle`;

const payloadToSign = "HUEBR";

function toBase64(data: string) : string {
    const buff = Buffer.from(data);
    return buff.toString('base64');
}

test('generate key 1024', () => {
    expect.assertions(1);
    return chevron.generateKey('abcd', 'abcd', 1024).catch((e: any|void) => expect(typeof e).toBe('string'));
});

test('generate key 2048', () => {
    expect.assertions(1);
    return chevron.generateKey('abcd', 'abcd', 2048).then((keyData: any|void) => expect(typeof keyData).toBe('string'));
});

test('load key', () => {
    expect.assertions(1);
    return chevron.loadKey(testKey).then((v: any|void) => expect(v).toBe(testKeyFingerprint));
});

test('load key invalid', () => {
    expect.assertions(1);
    return chevron.loadKey('HUEBR').catch((v: any|void) => expect(typeof v).toBe('string'));
});

test('verify signature', async () => {
  expect.assertions(1);
  await chevron.loadKey(testKey); // Load test key to have public key
  return chevron.verifySignature(toBase64(payloadToSign), testSignature).then((res: boolean|void) => expect(res).toBe(true));
});

test('verify signature invalid base64 payload', async () => {
  expect.assertions(1);
  await chevron.loadKey(testKey); // Load test key to have public key
  return chevron.verifySignature(payloadToSign, testSignature).catch((res: string) => expect(res).toBe('Expected a base64 encoded data'));
});

test('verify invalid signature payload', async () => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    return chevron.verifySignature(toBase64(payloadToSign + 'BLA'), testSignature).then((res: boolean|void) => expect(res).toBe(false));
});

test('verify invalid signature', async () => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    return chevron.verifySignature(toBase64(payloadToSign), testSignature.replace("B", "u")).catch((e: string|void) => expect(typeof e).toBe('string'));
});

test('test unlock key', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    return chevron.unlockKey(testKeyFingerprint, testKeyPassword).then((v: any|void) => expect(typeof v).toBe('string'));
});

test('test unlock key invalid password', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    return chevron.unlockKey(testKeyFingerprint, testKeyPassword + "balblablalbalb").catch((v: string|void) => expect(typeof v).toBe('string'));
});

test('generate signature', async () => {
    expect.assertions(3);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    const signature = await chevron.signData(toBase64(payloadToSign), testKeyFingerprint);
    expect(typeof signature).toBe('string');
    expect(signature.indexOf('PGP SIGNATURE')).toBeGreaterThan(-1);

    const verification = await chevron.verifySignature(toBase64(payloadToSign), signature);
    expect(verification).toBe(true);
});


test('generate signature invalid base64 payload', async () => {
  expect.assertions(1);
  await chevron.loadKey(testKey); // Load test key to have public key
  await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key
  chevron.signData(payloadToSign, testKeyFingerprint).catch((res: string) => expect(res).toBe('Expected a base64 encoded data'));
});


test('test generate signature locked key', async() => {
    expect.assertions(1);
    const key = await chevron.generateKey('abcd', 'abcd', 2048);
    const fp = await chevron.loadKey(key);
    return chevron.signData(toBase64(payloadToSign), fp).catch((e: string|void) => expect(typeof e).toBe('string'));
});

test('check base64', () => {
   expect(chevron.isBase64('huebr')).toBe(false);
   expect(chevron.isBase64('SFVFQlIK')).toBe(true);
});

test('get public key', async() => {
  expect.assertions(3);
  await chevron.loadKey(testKey); // Load test key to have public key
  const publicKey = chevron.getPublicKey(testKeyFingerprint);
  expect(publicKey.length).toBeGreaterThan(0);
  const fingerprints = chevron.getKeyFingerprints(publicKey);
  expect(fingerprints.length).toBeGreaterThan(0);
  expect(fingerprints[0]).toBe(testKeyFingerprint);
});


test('get public key not exists', async() => {
  expect.assertions(1);
  const getKey = () => chevron.getPublicKey('ABCDDEADBEEF');
  expect(getKey).toThrow();
});

test('verify signature quanto', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    const verification = await chevron.quantoVerifySignature(toBase64(payloadToSign), testQuantoSignature);
    expect(verification).toBe(true);
});

test('verify signature quanto invalid base64', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    return chevron.quantoVerifySignature(payloadToSign, testQuantoSignature).catch((res: string) => expect(res).toBe('Expected a base64 encoded data'));
});

test('verify signature quanto invalid payload', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    return chevron.quantoVerifySignature(toBase64(payloadToSign+"ABCD"), testQuantoSignature).then((res: boolean|void) => expect(res).toBe(false))
});

test('verify signature quanto invalid signature', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    return chevron.quantoVerifySignature(toBase64(payloadToSign), "ABCD").catch((res: string|void) => expect(typeof res).toBe('string'));
});

test('sign quanto', async() => {
    expect.assertions(4);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    const signature = await chevron.quantoSignData(toBase64(payloadToSign), testKeyFingerprint);

    expect(typeof signature).toBe('string');
    expect(signature.indexOf('PGP SIGNATURE')).toBe(-1);
    expect(signature.indexOf(testKeyFingerprint)).toBeGreaterThan(-1);

    const verification = await chevron.quantoVerifySignature(toBase64(payloadToSign), signature);
    expect(verification).toBe(true);
});

test('sign quanto', async() => {
    expect.assertions(1);
    await chevron.loadKey(testKey); // Load test key to have public key
    await chevron.unlockKey(testKeyFingerprint, testKeyPassword); // Unlock key

    chevron.quantoSignData(payloadToSign, testKeyFingerprint).catch((res: string) => expect(res).toBe('Expected a base64 encoded data'));
});

test('sign quanto invalid key', async() => {
    expect.assertions(1);

    return chevron.quantoSignData(toBase64(payloadToSign), "DEADBEEF1234").catch((res: string) => expect(typeof res).toBe('string'));
});
